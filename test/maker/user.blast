{"cells":[{"kind":2,"language":"javascript","value":"function ENat64(value) {\n    // Assuming value is a BigInt because JavaScript's Number type cannot accurately represent\n    // all Nat64 values (which are 64-bit unsigned integers).\n    return [\n        (value >> 56n) & 0xFFn,\n        (value >> 48n) & 0xFFn,\n        (value >> 40n) & 0xFFn,\n        (value >> 32n) & 0xFFn,\n        (value >> 24n) & 0xFFn,\n        (value >> 16n) & 0xFFn,\n        (value >> 8n) & 0xFFn,\n        value & 0xFFn,\n    ].map(n => Number(n)); // Convert BigInt to Number since Uint8Array needs numbers\n}\n\nfunction padArray(sourceArray, length, padding) {\n    const paddedArray = new Array(length).fill(padding);\n    sourceArray.forEach((element, index) => {\n        paddedArray[index] = element;\n    });\n    return paddedArray;\n}\n\nfunction sa(n) {\n    // Convert n to BigInt if it's not already, to handle numbers up to 64 bits\n    const nBigInt = BigInt(n);\n    const encoded = ENat64(nBigInt);\n    const padded = padArray(encoded, 32, 0);\n    return new Uint8Array(padded);\n}\n\nlet local = icblast({local:true, local_host:\"http://localhost:8080\"});\nlet can = await local(\"bd3sg-teaaa-aaaaa-qaaba-cai\");\nlet ledger = await local(\"bnz7o-iuaaa-aaaaa-qaaaa-cai\");\nglobal({can, sa, ledger})\n"},{"kind":2,"language":"javascript","value":"await can.start().then(log)"},{"kind":2,"language":"javascript","value":"await can.get_balance(null).then(x => log(toState(x)));"},{"kind":2,"language":"javascript","value":"await can.get_balance(sa(3)).then(log)"},{"kind":2,"language":"javascript","value":"await can.get_info().then(log);\nawait can.get_errors().then(log);"},{"kind":2,"language":"javascript","value":"await ledger.icrc1_balance_of({owner: \"be2us-64aaa-aaaaa-qaabq-cai\"}).then(log);\nawait ledger.icrc1_balance_of({owner: \"be2us-64aaa-aaaaa-qaabq-cai\", subaccount: sa(1)}).then(log);"},{"kind":2,"language":"javascript","value":"async function hashText(text) {\n  // Encode the string into a Uint8Array\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n\n  // Hash the data with SHA-256\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\n  // Convert the buffer to a hex string\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  return hashHex;\n}\n\n\n// Hashing all balances after test.\n// Replaying the history and hashing again should give the same result.\n\nlet acc = await can.accounts();\nawait hashText(JSON.stringify(toState(acc))).then(log);\n\n//27970b59c2a18bb8bfe312ba53c282131f6332bf688eeb765fa105525f622619"},{"kind":2,"language":"javascript","value":"// Compare local balances with ledger balances, must be the same\n\nlet acc = await can.accounts();\n\nfor (let i = 0; i < acc.length; i++) {\n    let [subaccount, balance] = acc[i];\n\n    let bal_remote = await ledger.icrc1_balance_of({owner: \"bd3sg-teaaa-aaaaa-qaaba-cai\", subaccount: (subaccount != \"\") ? subaccount : null });\n    if (balance != bal_remote) {\n        log({subaccount, balance, bal_remote});\n    }\n}"}]}